---
layout: default
sidebar: classes
title: "TraceLog"
description: "A class that contains all the information of the trace."
permalink: /class/tracelog
tags: [repodb, class, tracelog, orm, hybrid-orm, sqlserver, sqlite, mysql, postgresql]
parent: Classes
---

# TraceLog

---

A trace-logging class that is used when executing an operation. It provides vital information of the actual execution via the [ITrace](/interface/itrace) object.

### Properties

- `ExecutionTime` - handles the total elapsed time of the actual execution.
- `Parameter` - handles the parameters of the execution.
- `Result` - handles the actual execution result.
- `Statement` - handles the actual SQL statement generated by the library.

### Tracing

All methods of the [ITrace](/interface/itrace) interface is using this class. You can debug to any method of the [ITrace](/interface/itrace)-based classes to trace the actual execution information.

Let us say you have a custom trace class named `MyCustomTrace`. Then, you pass this object when you call the [Insert](/operation/insert) operation.

```csharp
using (var connection = new SqlConnection(connectionString))
{
    connection.Insert<Person>(person, trace: new MyCustomTrace());
}
```

Then, you can set a breakpoint at your `MyCustomTrace.BeforeInsert()` method and see the actual trace information before the actual execution via [CancellableTraceLog](/class/cancellabletracelog) argument.

```csharp
public void BeforeInsert(CancellableTraceLog log)
{
    Console.WriteLine($"BeforeInsert: {log.Statement}");
    if (log.Statement.IndexOf("INSERT") <= 0)
    {
        log.Cancel(true);
    }
}
```

Also, you can set a breakpoint at your `MyCustomTrace.AfterInsert()` method and see the actual trace information after the insert operation.

```csharp
public void AfterInsert(TraceLog log)
{
    Console.WriteLine($"AfterInsert: {log.Statement}, TotalTime: {log.ExecutionTime.TotalSeconds} second(s)");
}
```

> You can do the same in all operational method of the [ITrace](/interface/itrace)-based classes.